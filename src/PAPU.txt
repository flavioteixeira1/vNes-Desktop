import javax.sound.sampled.*;
import java.io.*;
import java.util.Scanner;

public final class PAPU {
    
    // Sistema de √°udio moderno (principal)
    private ModernAudioSystem modernAudio;
    private boolean audioEnabled = true;
    private long lastLogTime = 0;
    private byte[] audioBuffer;
    private int bufferIndex = 0;
    private static final int SAMPLE_RATE = 44100;
    private static final int BUFFER_SIZE = 4096;
    private long lastAudioActivity = 0;
    private int framesSinceLastAudio = 0;
    private static final int AUDIO_UPDATE_INTERVAL = 2; // Processar √°udio a cada 2 frames
    
    // Refer√™ncias do NES
    NES nes;
    Memory cpuMem;
    Mixer mixer;
    SourceDataLine line;
    
    // Canais de √°udio
    ChannelSquare square1;
    ChannelSquare square2;
    ChannelTriangle triangle;
    ChannelNoise noise;
    ChannelDM dmc;
    
    // Lookup tables
    int[] lengthLookup;
    int[] dmcFreqLookup;
    int[] noiseWavelengthLookup;
    int[] square_table;
    int[] tnd_table;
    int[] ismpbuffer;
    byte[] sampleBuffer;
    
    // Configura√ß√£o de √°udio
    int bufferSize = 2048;
    int sampleRate = 44100;
    boolean stereo = true;
    
    // Controles de usu√°rio
    private boolean userEnableSquare1 = true;
    private boolean userEnableSquare2 = true;
    private boolean userEnableTriangle = true;
    private boolean userEnableNoise = true;
    public boolean userEnableDmc = true;
    
    // Estado do APU
    int masterFrameCounter;
    int derivedFrameCounter;
    int countSequence;
    int sampleTimer;
    int sampleTimerMax;
    int frameTime;
    int sampleCount;
    short channelEnableValue;
    
    // Amostragem e mixagem
    int smpSquare1, smpSquare2, smpTriangle, smpNoise, smpDmc;
    int accCount;
    int sampleValueL, sampleValueR;
    int triValue = 0;
    int sq_index, tnd_index;
    
    // Panning e stereo
    int masterVolume;
    int[] panning;
    int stereoPosLSquare1, stereoPosLSquare2, stereoPosLTriangle, stereoPosLNoise, stereoPosLDMC;
    int stereoPosRSquare1, stereoPosRSquare2, stereoPosRTriangle, stereoPosRNoise, stereoPosRDMC;
    
    // Processamento de sinal
    int prevSampleL = 0, prevSampleR = 0;
    int smpAccumL = 0, smpAccumR = 0;
    int smpDiffL = 0, smpDiffR = 0;
    int dacRange = 0;
    int dcValue = 0;
    
    // Contadores e IRQ
    int frameIrqCounter;
    int frameIrqCounterMax;
    int initCounter;
    boolean frameIrqEnabled;
    boolean frameIrqActive;
    boolean frameClockNow;
    boolean startedPlaying = false;
    boolean recordOutput = false;
    boolean initingHardware = false;
    
    // Timing
    int extraCycles;
    int maxCycles;
    
    // Vari√°veis tempor√°rias
    byte b1, b2, b3, b4;

    public PAPU(NES nes) {
        this.nes = nes;
        this.cpuMem = nes.getCpuMemory();
        // Inicializar componentes do APU primeiro
        initializeAPUComponents();
        // Inicializar sistema de √°udio moderno
        initializeModernAudio();
        // Inicializar lookup tables
        initializeLookupTables();

         // TESTE: Verificar se o √°udio funciona (APENAS UMA VEZ)
        if (Globals.enableSound && modernAudio != null && modernAudio.isInitialized()) {
            new Thread(() -> {
                try {
                    Thread.sleep(2000); // Esperar 2 segundos
                    testAudioSystem();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
}
        // Configura√ß√£o inicial
        reset();
    }



    public int getBufferIndex() {
        return bufferIndex;
    }


     public void close() {
        if (line != null) {
            line.close();
            line = null;
        }
    }


    private boolean initializeWithPreferredMixer() {
            System.out.println("üîä Inicializando com mixer preferido: Intel [plughw:0,0]");
            
            try {
                // Usar o ModernAudioSystem normalmente, mas for√ßar o mixer espec√≠fico
                modernAudio = new ModernAudioSystem();
                
                // O ModernAudioSystem j√° tem l√≥gica para tentar mixers espec√≠ficos
                // Vamos apenas garantir que ele tente o nosso preferido primeiro
                boolean success = modernAudio.initialize();
                
                if (success) {
                    System.out.println("‚úÖ √Åudio inicializado com sucesso");
                    audioEnabled = true;
                } else {
                    System.err.println("‚ùå Falha na inicializa√ß√£o do √°udio");
                    audioEnabled = false;
                }
                
                return success;
                
            } catch (Exception e) {
                System.err.println("‚ùå Erro na inicializa√ß√£o do √°udio: " + e.getMessage());
                audioEnabled = false;
                return false;
            }
    }







   private void initializeModernAudio() {
            System.out.println("PAPU.initializeModernAudio() - Inicializando √°udio moderno...");
            modernAudio = new ModernAudioSystem();
            audioEnabled = modernAudio.initialize();
             // Tentar inicializar com o mixer preferido
            //  audioEnabled = initializeWithPreferredMixer();

            if (audioEnabled) {
                // TESTAR SE O √ÅUDIO EST√Å REALMENTE FUNCIONANDO
                System.out.println("üß™ Testando reprodu√ß√£o de √°udio...");
                boolean testPassed = modernAudio.testAudio();
                if (testPassed) {
                System.out.println("‚úÖ Sistema de √°udio inicializado e testado com sucesso");
            } else {
                System.err.println("‚ùå Teste de √°udio falhou - sistema pode n√£o funcionar");
                audioEnabled = false;
            }
                
            }else {  System.err.println("‚ùå Sistema de √°udio falhou - tentando fallback...");
            // Tentar fallback ap√≥s um delay
                new Thread(() -> {
                    try {
                        Thread.sleep(2000); // Esperar 2 segundos
                         attemptAudioFallback();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            } 
        }

        private void attemptAudioFallback() {
        System.out.println("üîÑ Tentando fallback de √°udio...");
                try {
                    // Tentar inicializar novamente
                    modernAudio = new ModernAudioSystem();
                    audioEnabled = modernAudio.initialize();
                    
                    if (audioEnabled) {
                        System.out.println("‚úÖ Fallback de √°udio bem-sucedido!");
                    } else {
                        System.err.println("‚ùå Fallback de √°udio tamb√©m falhou - emulando sem √°udio");
                    }
                } catch (Exception e) {
                    System.err.println("‚ùå Erro no fallback de √°udio: " + e.getMessage()); }
         }
         

  public void writeSample(byte[] samples) {
        if (!audioEnabled || modernAudio == null) {
            // Tentar reativar se houver atividade recente
            if (System.currentTimeMillis() - lastAudioActivity < 1000) {
                attemptAudioRecovery();
            }
            return;
        }
        // Verificar se o √°udio ainda est√° vivo
        if (!modernAudio.isAudioAlive()) {
            System.out.println("üîÑ √Åudio inativo, tentando recuperar...");
            audioEnabled = modernAudio.initialize();
            if (!audioEnabled) return;
        }
        
        try {
            modernAudio.write(samples);
        } catch (Exception e) {
            System.err.println("Erro no envio de √°udio: " + e.getMessage());
            audioEnabled = false;
        }
    }


    private void attemptAudioRecovery() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastAudioActivity < 5000) { // Tentar recuperar apenas se atividade recente
            System.out.println("üîÑ Tentando recuperar √°udio...");
            audioEnabled = modernAudio.initialize();
        }
    }

    


    public void writeAudioData(byte[] audioData) {
        if (modernAudio != null) {
            modernAudio.write(audioData);
        }

    }


    public void stop() {
        if (modernAudio != null) {
            modernAudio.close();;
        }
    }
    
    private void initializeAPUComponents() {
        setSampleRate(sampleRate, false);
         // INICIALIZAR O audioBuffer AQUI 
        this.audioBuffer = new byte[BUFFER_SIZE * 4]; // stereo 16-bit = 4 bytes por sample
        this.bufferIndex = 0;
        sampleBuffer = new byte[bufferSize * (stereo ? 4 : 2)];
        ismpbuffer = new int[bufferSize * (stereo ? 2 : 1)];
        bufferIndex = 0;
        frameIrqEnabled = false;
        initCounter = 2048;
        
        square1 = new ChannelSquare(this, true);
        square2 = new ChannelSquare(this, false);
        triangle = new ChannelTriangle(this);
        noise = new ChannelNoise(this);
        dmc = new ChannelDM(this);
        
        masterVolume = 256;
        panning = new int[]{80, 170, 100, 150, 128};
        setPanning(panning);
        
        frameIrqEnabled = false;
        frameIrqCounterMax = 4;
    }
    
    private void initializeLookupTables() {
        initLengthLookup();
        initDmcFrequencyLookup();
        initNoiseWavelengthLookup();
        initDACtables();
    }

    public static void checkAudioSystem() {
        System.out.println("=== DIAGN√ìSTICO DE √ÅUDIO ===");
        System.out.println("Java Version: " + System.getProperty("java.version"));
        
        // Listar mixers dispon√≠veis
        Mixer.Info[] mixerInfos = AudioSystem.getMixerInfo();
        System.out.println("Mixers dispon√≠veis: " + mixerInfos.length);
        
        for (Mixer.Info info : mixerInfos) {
            System.out.println("Mixer: " + info.getName());
            System.out.println("  Descri√ß√£o: " + info.getDescription());
            System.out.println("  Vendor: " + info.getVendor());
            
            Mixer mixer = AudioSystem.getMixer(info);
            Line.Info[] sourceLines = mixer.getSourceLineInfo();
            Line.Info[] targetLines = mixer.getTargetLineInfo();
            
            System.out.println("  Linhas de origem: " + sourceLines.length);
            System.out.println("  Linhas de destino: " + targetLines.length);
        }
        
        // Verificar formatos suportados
        AudioFormat format = new AudioFormat(44100, 16, 2, true, false);
        DataLine.Info lineInfo = new DataLine.Info(SourceDataLine.class, format);
        
        System.out.println("Formato 44100Hz 16-bit stereo suportado: " + 
                          AudioSystem.isLineSupported(lineInfo));
        
        System.out.println("=== FIM DO DIAGN√ìSTICO ===");
    }

    public void stateLoad(ByteBuffer buf) {
        // not yet.
    }

    public void stateSave(ByteBuffer buf) {
        // not yet.
    }

    public synchronized void start() {
        // SE √ÅUDIO ESTIVER DESABILITADO, N√ÉO INICIALIZAR
        if (!Globals.enableSound) {
            return;
        }
        if (modernAudio != null && modernAudio.initialize()) {
           System.out.println("PAPU - Sistema de √°udio j√° inicializado, ignorando nova inicializa√ß√£o");
            return;
        }
        
            // Inicializar apenas uma vez
        if (modernAudio == null) {
            modernAudio = new ModernAudioSystem();
        }
        
        if (!modernAudio.isInitialized()) {
            audioEnabled = modernAudio.initialize();
        }
        
        if (audioEnabled) {
            System.out.println("‚úÖ Sistema de √°udio pronto para emula√ß√£o");
        }
    }

    public NES getNes() {
        return nes;
    }

    public short readReg(int address) {
        if (address == 0x4015) {
            int tmp = 0;
            tmp |= (square1.getLengthStatus());
            tmp |= (square2.getLengthStatus() << 1);
            tmp |= (triangle.getLengthStatus() << 2);
            tmp |= (noise.getLengthStatus() << 3);
            tmp |= (dmc.getLengthStatus() << 4);
            tmp |= (((frameIrqActive && frameIrqEnabled) ? 1 : 0) << 6);
            tmp |= (dmc.getIrqStatus() << 7);
            
            frameIrqActive = false;
            dmc.irqGenerated = false;
            
            return (short) tmp;
        }
        return 0;
    }

    public void writeReg(int address, short value) {
        switch (address) {
            case 0x4000: case 0x4001: case 0x4002: case 0x4003:
                square1.writeReg(address, value);
                break;
            case 0x4004: case 0x4005: case 0x4006: case 0x4007:
                square2.writeReg(address, value);
                break;
            case 0x4008: case 0x4009: case 0x400A: case 0x400B:
                triangle.writeReg(address, value);
                break;
            case 0x400C: case 0x400D: case 0x400E: case 0x400F:
                noise.writeReg(address, value);
                break;
            case 0x4010: case 0x4011: case 0x4012: case 0x4013:
                dmc.writeReg(address, value);
                break;
            case 0x4015:
                updateChannelEnable(value);
                if (value != 0 && initCounter > 0) {
                    initingHardware = true;
                }
                dmc.writeReg(address, value);
                break;
            case 0x4017:
                countSequence = (value >> 7) & 1;
                masterFrameCounter = 0;
                frameIrqActive = false;
                frameIrqEnabled = ((value >> 6) & 0x1) == 0;
                
                if (countSequence == 0) {
                    frameIrqCounterMax = 4;
                    derivedFrameCounter = 4;
                } else {
                    frameIrqCounterMax = 5;
                    derivedFrameCounter = 0;
                    frameCounterTick();
                }
                break;
        }
    }

    public void resetCounter() {
        if (countSequence == 0) {
            derivedFrameCounter = 4;
        } else {
            derivedFrameCounter = 0;
        }
    }

    public void updateChannelEnable(int value) {
        channelEnableValue = (short) value;
        square1.setEnabled(userEnableSquare1 && (value & 1) != 0);
        square2.setEnabled(userEnableSquare2 && (value & 2) != 0);
        triangle.setEnabled(userEnableTriangle && (value & 4) != 0);
        noise.setEnabled(userEnableNoise && (value & 8) != 0);
        dmc.setEnabled(userEnableDmc && (value & 16) != 0);
    }

    public void clockFrameCounter(int nCycles) {
        // SE √ÅUDIO ESTIVER DESABILITADO, N√ÉO FAZER NADA
        if (!Globals.enableSound) {
            return;
        }
        if (initCounter > 0 && initingHardware) {
            initCounter -= nCycles;
            if (initCounter <= 0) initingHardware = false;
            return;
        }
        
        // Processar ciclos com tratamento de overflow
        nCycles += extraCycles;
        maxCycles = sampleTimerMax - sampleTimer;
        
        if ((nCycles << 10) > maxCycles) {
            extraCycles = ((nCycles << 10) - maxCycles) >> 10;
            nCycles -= extraCycles;
        } else {
            extraCycles = 0;
        }
        
        // Clock dos canais
        clockDmc(nCycles);
        clockTriangle(nCycles);
        clockSquare1(nCycles);
        clockSquare2(nCycles);
        clockNoise(nCycles);
        
        // IRQ de frame
        if (frameIrqEnabled && frameIrqActive) {
            nes.cpu.requestIrq(CPU.IRQ_NORMAL);
        }
        
        // Clock do frame counter
        masterFrameCounter += (nCycles << 1);
        if (masterFrameCounter >= frameTime) {
            masterFrameCounter -= frameTime;
            frameCounterTick();
        }
        
        // Amostragem
        accSample(nCycles);

        // Manter registro de atividade de √°udio
        if (nCycles > 0) {
            lastAudioActivity = System.currentTimeMillis();
        }
        
        // Timer de amostragem
        sampleTimer += nCycles << 10;
        if (sampleTimer >= sampleTimerMax) {
            sample();
            sampleTimer -= sampleTimerMax;
        }
    }
    
    private void clockDmc(int nCycles) {
        if (dmc.isEnabled) {
            dmc.shiftCounter -= (nCycles << 3);
            while (dmc.shiftCounter <= 0 && dmc.dmaFrequency > 0) {
                dmc.shiftCounter += dmc.dmaFrequency;
                dmc.clockDmc();
            }
        }
    }
    
    private void clockTriangle(int nCycles) {
        if (triangle.progTimerMax > 0) {
            triangle.progTimerCount -= nCycles;
            while (triangle.progTimerCount <= 0) {
                triangle.progTimerCount += triangle.progTimerMax + 1;
                if (triangle.linearCounter > 0 && triangle.lengthCounter > 0) {
                    triangle.triangleCounter++;
                    triangle.triangleCounter &= 0x1F;
                    
                    if (triangle.isEnabled) {
                        if (triangle.triangleCounter >= 0x10) {
                            triangle.sampleValue = (triangle.triangleCounter & 0xF);
                        } else {
                            triangle.sampleValue = (0xF - (triangle.triangleCounter & 0xF));
                        }
                        triangle.sampleValue <<= 4;
                    }
                }
            }
        }
    }
    
    private void clockSquare1(int nCycles) {
        square1.progTimerCount -= nCycles;
        if (square1.progTimerCount <= 0) {
            square1.progTimerCount += (square1.progTimerMax + 1) << 1;
            square1.squareCounter++;
            square1.squareCounter &= 0x7;
            square1.updateSampleValue();
        }
    }
    
    private void clockSquare2(int nCycles) {
        square2.progTimerCount -= nCycles;
        if (square2.progTimerCount <= 0) {
            square2.progTimerCount += (square2.progTimerMax + 1) << 1;
            square2.squareCounter++;
            square2.squareCounter &= 0x7;
            square2.updateSampleValue();
        }
    }
    
    private void clockNoise(int nCycles) {
        int acc_c = nCycles;
        if (noise.progTimerCount - acc_c > 0) {
            noise.progTimerCount -= acc_c;
            noise.accCount += acc_c;
            noise.accValue += acc_c * noise.sampleValue;
        } else {
            while ((acc_c--) > 0) {
                if (--noise.progTimerCount <= 0 && noise.progTimerMax > 0) {
                    noise.shiftReg <<= 1;
                    noise.tmp = (((noise.shiftReg << (noise.randomMode == 0 ? 1 : 6)) ^ noise.shiftReg) & 0x8000);
                    if (noise.tmp != 0) {
                        noise.shiftReg |= 0x01;
                        noise.randomBit = 0;
                        noise.sampleValue = 0;
                    } else {
                        noise.randomBit = 1;
                        noise.sampleValue = noise.isEnabled && noise.lengthCounter > 0 ? noise.masterVolume : 0;
                    }
                    noise.progTimerCount += noise.progTimerMax;
                }
                noise.accValue += noise.sampleValue;
                noise.accCount++;
            }
        }
    }

    private void accSample(int cycles) {
        // Interpola√ß√£o do canal triangle
        if (triangle.sampleCondition) {
            triValue = (triangle.progTimerCount << 4) / (triangle.progTimerMax + 1);
            if (triValue > 16) triValue = 16;
            if (triangle.triangleCounter >= 16) {
                triValue = 16 - triValue;
            }
            triValue += triangle.sampleValue;
        }
        
        // Acumular amostras
        if (cycles == 2) {
            smpTriangle += triValue << 1;
            smpDmc += dmc.sample << 1;
            smpSquare1 += square1.sampleValue << 1;
            smpSquare2 += square2.sampleValue << 1;
            accCount += 2;
        } else if (cycles == 4) {
            smpTriangle += triValue << 2;
            smpDmc += dmc.sample << 2;
            smpSquare1 += square1.sampleValue << 2;
            smpSquare2 += square2.sampleValue << 2;
            accCount += 4;
        } else {
            smpTriangle += cycles * triValue;
            smpDmc += cycles * dmc.sample;
            smpSquare1 += cycles * square1.sampleValue;
            smpSquare2 += cycles * square2.sampleValue;
            accCount += cycles;
        }
    }

    public void frameCounterTick() {
        derivedFrameCounter++;
        if (derivedFrameCounter >= frameIrqCounterMax) {
            derivedFrameCounter = 0;
        }
        
        if (derivedFrameCounter == 1 || derivedFrameCounter == 3) {
            triangle.clockLengthCounter();
            square1.clockLengthCounter();
            square2.clockLengthCounter();
            noise.clockLengthCounter();
            square1.clockSweep();
            square2.clockSweep();
        }
        
        if (derivedFrameCounter >= 0 && derivedFrameCounter < 4) {
            square1.clockEnvDecay();
            square2.clockEnvDecay();
            noise.clockEnvDecay();
            triangle.clockLinearCounter();
        }
        
        if (derivedFrameCounter == 3 && countSequence == 0) {
            frameIrqActive = true;
        }
    }


    public void sample() {
        // SE √ÅUDIO ESTIVER DESABILITADO, N√ÉO FAZER NADA
        if (!Globals.enableSound) {
            resetSampleValues();
            return;
        }

        if (!Globals.enableSound || modernAudio == null || audioBuffer == null) {
            resetSampleValues();
            return;
        }

        // OTIMIZA√á√ÉO: Processar √°udio apenas a cada X frames para melhor performance
        framesSinceLastAudio++;
        if (framesSinceLastAudio < AUDIO_UPDATE_INTERVAL) {
            resetSampleValues();
            return;
        }
        framesSinceLastAudio = 0;

        try {
            // MIXAGEM OTIMIZADA
            if (accCount > 0) {
                int mixedSample = mixChannels();
                
                // Adicionar ao buffer
                addSample((short) mixedSample, (short) mixedSample);
            }
        } catch (Exception e) {
            System.err.println("Erro no sample: " + e.getMessage());
        }
        
        resetSampleValues();
    }




    private void debugAudioState() {
            if (sampleCount++ % 200 == 0) { // Log a cada 200 samples
                System.out.println("Audio Debug - " +
                    "Square1: " + smpSquare1 + ", " +
                    "Square2: " + smpSquare2 + ", " +
                    "Triangle: " + smpTriangle + ", " +
                    "Noise: " + smpNoise + ", " +
                    "DMC: " + smpDmc + ", " +
                    "Buffer: " + bufferIndex + "/" + audioBuffer.length);
            }
      }




    private int mixChannels() {
                    try {
                        // Mixagem b√°sica dos canais com prote√ß√£o contra overflow
                        long mixed = 0;
                        int channelCount = 0;
                        
                        if (userEnableSquare1 && smpSquare1 != 0) {
                            mixed += (long)smpSquare1 * 500;
                            channelCount++;
                        }
                        if (userEnableSquare2 && smpSquare2 != 0) {
                            mixed += (long)smpSquare2 * 500;
                            channelCount++;
                        }
                        if (userEnableTriangle && smpTriangle != 0) {
                            mixed += (long)smpTriangle * 800;
                            channelCount++;
                        }
                        if (userEnableNoise && smpNoise != 0) {
                            mixed += (long)smpNoise * 1200;
                            channelCount++;
                        }
                        if (userEnableDmc && smpDmc != 0) {
                            mixed += (long)smpDmc * 2000;
                            channelCount++;
                        }
                        
                        // Normalizar e converter para int com seguran√ßa
                        if (channelCount > 0) {
                            mixed = mixed / channelCount;
                        }
                        
                        // Limitar o valor para evitar overflow
                        if (mixed > Integer.MAX_VALUE) mixed = Integer.MAX_VALUE;
                        if (mixed < Integer.MIN_VALUE) mixed = Integer.MIN_VALUE;
                        
                        return (int)mixed;
                        
                    } catch (Exception e) {
                        System.err.println("Erro na mixagem: " + e.getMessage());
                        return 0;
                    }
        }



    private void mixSamples() {
        if (stereo) {
            // Mixagem stereo
            sq_index = (smpSquare1 * stereoPosLSquare1 + smpSquare2 * stereoPosLSquare2) >> 8;
            tnd_index = (3 * smpTriangle * stereoPosLTriangle + (smpNoise << 1) * stereoPosLNoise + smpDmc * stereoPosLDMC) >> 8;
            
            sq_index = Math.min(sq_index, square_table.length - 1);
            tnd_index = Math.min(tnd_index, tnd_table.length - 1);
            sampleValueL = square_table[sq_index] + tnd_table[tnd_index] - dcValue;
            
            sq_index = (smpSquare1 * stereoPosRSquare1 + smpSquare2 * stereoPosRSquare2) >> 8;
            tnd_index = (3 * smpTriangle * stereoPosRTriangle + (smpNoise << 1) * stereoPosRNoise + smpDmc * stereoPosRDMC) >> 8;
            
            sq_index = Math.min(sq_index, square_table.length - 1);
            tnd_index = Math.min(tnd_index, tnd_table.length - 1);
            sampleValueR = square_table[sq_index] + tnd_table[tnd_index] - dcValue;
        } else {
            // Mixagem mono
            sq_index = smpSquare1 + smpSquare2;
            tnd_index = 3 * smpTriangle + 2 * smpNoise + smpDmc;
            
            sq_index = Math.min(sq_index, square_table.length - 1);
            tnd_index = Math.min(tnd_index, tnd_table.length - 1);
            sampleValueL = 3 * (square_table[sq_index] + tnd_table[tnd_index] - dcValue) >> 2;
        }
        
        // Remover DC
        removeDCOffset();
    }
    
    private void removeDCOffset() {
        smpDiffL = sampleValueL - prevSampleL;
        prevSampleL += smpDiffL;
        smpAccumL += smpDiffL - (smpAccumL >> 10);
        sampleValueL = smpAccumL;
        
        if (stereo) {
            smpDiffR = sampleValueR - prevSampleR;
            prevSampleR += smpDiffR;
            smpAccumR += smpDiffR - (smpAccumR >> 10);
            sampleValueR = smpAccumR;
        }
    }
    
    private void writeToAudioBuffer() {
        if (!Globals.enableSound || modernAudio == null || !modernAudio.initialize()) {
            return;
        }
        
        if (stereo) {
            addSample((short) sampleValueL, (short) sampleValueR);
        } else {
            addSample((short) sampleValueL, (short) sampleValueL);
        }
    }
    
    public void addSample(short left, short right) {
        if (!Globals.enableSound || audioBuffer == null || modernAudio == null) {
        return;
        }

         // VERIFICA√á√ÉO DE SEGURAN√áA ADICIONAL
         if (bufferIndex < 0 || bufferIndex >= audioBuffer.length - 3) {
          bufferIndex = 0; // Reset se estiver fora dos limites
         }
        
        if (bufferIndex >= audioBuffer.length) {
            writeBuffer();
        }

        try {
        // Escrever samples (16-bit little endian)
        audioBuffer[bufferIndex++] = (byte) (left & 0xFF);
        audioBuffer[bufferIndex++] = (byte) ((left >> 8) & 0xFF);
        audioBuffer[bufferIndex++] = (byte) (right & 0xFF);
        audioBuffer[bufferIndex++] = (byte) ((right >> 8) & 0xFF);
        
        // For√ßar escrita quando o buffer estiver 75% cheio
        if (bufferIndex >= audioBuffer.length * 3 / 4) {
            writeBuffer();
              }
            } catch (Exception e) {
                System.err.println("Erro em addSample: " + e.getMessage());
                bufferIndex = 0; // Reset em caso de erro
            }

    }

    public void writeBufferSimple() {
            if (!Globals.enableSound || bufferIndex == 0) return;
            
            try {
                // Usar AudioSystem diretamente como fallback
                AudioFormat format = new AudioFormat(44100, 16, 2, true, false);
                DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);
                
                if (AudioSystem.isLineSupported(info)) {
                    SourceDataLine testLine = (SourceDataLine) AudioSystem.getLine(info);
                    testLine.open(format, 4410); // Buffer pequeno para teste
                    testLine.start();
                    
                    testLine.write(audioBuffer, 0, bufferIndex);
                    testLine.drain();
                    testLine.close();
                    
                    System.out.println("‚úì √Åudio reproduzido via fallback");
                }
                
            } catch (Exception e) {
                System.err.println("Erro no fallback de √°udio: " + e.getMessage());
            }
            
            bufferIndex = 0;
        }


        public void writeBuffer() {
        if (!Globals.enableSound || modernAudio == null || bufferIndex == 0) {
            return;
        }
    
        try {
            // OTIMIZA√á√ÉO: Escrever apenas se tiver dados suficientes
            int minWriteSize = 512; // Escrever pelo menos 512 bytes
            if (bufferIndex >= minWriteSize) {
                modernAudio.write(audioBuffer, 0, bufferIndex);
                bufferIndex = 0;
            }
            
        } catch (Exception e) {
            System.err.println("Erro em writeBuffer: " + e.getMessage());
            bufferIndex = 0;
        }   
    }




    public int getSampleRate() {
        return sampleRate;
    }

    public void reset() {
        setSampleRate(sampleRate, false);
        updateChannelEnable(0);
        masterFrameCounter = 0;
        derivedFrameCounter = 0;
        countSequence = 0;
        sampleCount = 0;
        initCounter = 2048;
        frameIrqEnabled = false;
        initingHardware = false;

        resetCounter();

        square1.reset();
        square2.reset();
        triangle.reset();
        noise.reset();
        dmc.reset();

        bufferIndex = 0;
        accCount = 0;
        smpSquare1 = 0;
        smpSquare2 = 0;
        smpTriangle = 0;
        smpNoise = 0;
        smpDmc = 0;

        frameIrqEnabled = false;
        frameIrqCounterMax = 4;
        channelEnableValue = 0;

        sampleValueL = 0;
        sampleValueR = 0;
        prevSampleL = 0;
        prevSampleR = 0;
        smpAccumL = 0;
        smpAccumR = 0;
        smpDiffL = 0;
        smpDiffR = 0;
    }
    
    private void resetSampleValues() {
        smpSquare1 = 0;
        smpSquare2 = 0;
        smpTriangle = 0;
        smpNoise = 0;
        smpDmc = 0;
    }



    public int getLengthMax(int value) {
        return lengthLookup[value >> 3];
    }

    public int getDmcFrequency(int value) {
        if (value >= 0 && value < 0x10) {
            return dmcFreqLookup[value];
        }
        return 0;
    }

    public int getNoiseWaveLength(int value) {
        if (value >= 0 && value < 0x10) {
            return noiseWavelengthLookup[value];
        }
        return 0;
    }

    public synchronized void setSampleRate(int rate, boolean restart) {
        System.out.println("Definindo sample rate para: " + rate + "Hz");
        boolean cpuRunning = nes.isRunning();
        if (cpuRunning) {
            nes.stopEmulation();
        }

        sampleRate = rate;
        sampleTimerMax = (int) ((1024.0 * Globals.CPU_FREQ_NTSC * Globals.preferredFrameRate) /
                (sampleRate * 60.0d));

        frameTime = (int) ((14915.0 * (double) Globals.preferredFrameRate) / 60.0d);

        sampleTimer = 0;
        bufferIndex = 0;

       
        System.out.println("Sample timer max: " + sampleTimerMax);

        if (restart) {
            stop();
            start();
        }

        if (cpuRunning) {
            nes.startEmulation();
        }
    }

    public synchronized void setStereo(boolean s, boolean restart) {
        if (stereo == s) {
            return;
        }

        boolean running = nes.isRunning();
        nes.stopEmulation();

        stereo = s;
        if (stereo) {
            sampleBuffer = new byte[bufferSize * 4];
        } else {
            sampleBuffer = new byte[bufferSize * 2];
        }

        if (restart) {
            stop();
            start();
        }

        if (running) {
            nes.startEmulation();
        }
    }

    public int getPapuBufferSize() {
        return sampleBuffer.length;
    }

    public void setChannelEnabled(int channel, boolean value) {
        switch (channel) {
            case 0:
                userEnableSquare1 = value;
                break;
            case 1:
                userEnableSquare2 = value;
                break;
            case 2:
                userEnableTriangle = value;
                break;
            case 3:
                userEnableNoise = value;
                break;
            case 4:
                userEnableDmc = value;
                break;
        }
        updateChannelEnable(channelEnableValue);
    }

    public void setPanning(int[] pos) {
        for (int i = 0; i < 5; i++) {
            panning[i] = pos[i];
        }
        updateStereoPos();
    }

    public void setMasterVolume(int value) {
        if (value < 0) value = 0;
        if (value > 256) value = 256;
        masterVolume = value;
        updateStereoPos();
    }

    public void updateStereoPos() {
        stereoPosLSquare1 = (panning[0] * masterVolume) >> 8;
        stereoPosLSquare2 = (panning[1] * masterVolume) >> 8;
        stereoPosLTriangle = (panning[2] * masterVolume) >> 8;
        stereoPosLNoise = (panning[3] * masterVolume) >> 8;
        stereoPosLDMC = (panning[4] * masterVolume) >> 8;

        stereoPosRSquare1 = masterVolume - stereoPosLSquare1;
        stereoPosRSquare2 = masterVolume - stereoPosLSquare2;
        stereoPosRTriangle = masterVolume - stereoPosLTriangle;
        stereoPosRNoise = masterVolume - stereoPosLNoise;
        stereoPosRDMC = masterVolume - stereoPosLDMC;
    }

    public SourceDataLine getLine() {

        if (line == null) {
            initializeAudio();
        }
        return line;
    }


    private void initializeAudio() {
                try {
                    AudioFormat format = new AudioFormat(44100, 8, 1, true, true);
                    line = AudioSystem.getSourceDataLine(format);
                    line.open(format, 4410);
                    line.start();
                } catch (LineUnavailableException e) {
                    System.err.println("Audio initialization failed: " + e.getMessage());
                    line = null;
                }
    }
        

    public boolean isRunning() {
    return (modernAudio != null && modernAudio.isInitialized());
     }

    
	public int getMillisToAvailableAbove(int target_avail) {
    // Para o sistema moderno, sempre retornar 0 (dispon√≠vel)
    // ou implementar l√≥gica baseada no buffer interno
    if (modernAudio != null && modernAudio.initialize()) {
        // Estimar baseado no nosso buffer interno
        int currentBufferSpace = BUFFER_SIZE - bufferIndex;
        if (currentBufferSpace >= target_avail) {
            return 0;
        }
        
        // Calcular tempo estimado para liberar espa√ßo
        int bytesNeeded = target_avail - currentBufferSpace;
        long estimatedMillis = (bytesNeeded * 1000L) / (sampleRate * (stereo ? 4 : 2));
        return (int) Math.max(0, estimatedMillis);
    }
    
    return 0; // Fallback
    }



    public int getBufferPos() {
        return bufferIndex;
    }

    public void initLengthLookup() {
        lengthLookup = new int[]{
            0x0A, 0xFE,
            0x14, 0x02,
            0x28, 0x04,
            0x50, 0x06,
            0xA0, 0x08,
            0x3C, 0x0A,
            0x0E, 0x0C,
            0x1A, 0x0E,
            0x0C, 0x10,
            0x18, 0x12,
            0x30, 0x14,
            0x60, 0x16,
            0xC0, 0x18,
            0x48, 0x1A,
            0x10, 0x1C,
            0x20, 0x1E
        };
    }

    public void initDmcFrequencyLookup() {
        dmcFreqLookup = new int[16];

        dmcFreqLookup[0x0] = 0xD60;
        dmcFreqLookup[0x1] = 0xBE0;
        dmcFreqLookup[0x2] = 0xAA0;
        dmcFreqLookup[0x3] = 0xA00;
        dmcFreqLookup[0x4] = 0x8F0;
        dmcFreqLookup[0x5] = 0x7F0;
        dmcFreqLookup[0x6] = 0x710;
        dmcFreqLookup[0x7] = 0x6B0;
        dmcFreqLookup[0x8] = 0x5F0;
        dmcFreqLookup[0x9] = 0x500;
        dmcFreqLookup[0xA] = 0x470;
        dmcFreqLookup[0xB] = 0x400;
        dmcFreqLookup[0xC] = 0x350;
        dmcFreqLookup[0xD] = 0x2A0;
        dmcFreqLookup[0xE] = 0x240;
        dmcFreqLookup[0xF] = 0x1B0;
    }

    public void initNoiseWavelengthLookup() {
        noiseWavelengthLookup = new int[16];

        noiseWavelengthLookup[0x0] = 0x004;
        noiseWavelengthLookup[0x1] = 0x008;
        noiseWavelengthLookup[0x2] = 0x010;
        noiseWavelengthLookup[0x3] = 0x020;
        noiseWavelengthLookup[0x4] = 0x040;
        noiseWavelengthLookup[0x5] = 0x060;
        noiseWavelengthLookup[0x6] = 0x080;
        noiseWavelengthLookup[0x7] = 0x0A0;
        noiseWavelengthLookup[0x8] = 0x0CA;
        noiseWavelengthLookup[0x9] = 0x0FE;
        noiseWavelengthLookup[0xA] = 0x17C;
        noiseWavelengthLookup[0xB] = 0x1FC;
        noiseWavelengthLookup[0xC] = 0x2FA;
        noiseWavelengthLookup[0xD] = 0x3F8;
        noiseWavelengthLookup[0xE] = 0x7F2;
        noiseWavelengthLookup[0xF] = 0xFE4;
    }

    public void initDACtables() {
        square_table = new int[32 * 16];
        tnd_table = new int[204 * 16];
        double value;

        int ival;
        int max_sqr = 0;
        int max_tnd = 0;

        for (int i = 0; i < 32 * 16; i++) {
            value = 95.52 / (8128.0 / ((double) i / 16.0) + 100.0);
            value *= 0.98411;
            value *= 50000.0;
            ival = (int) value;

            square_table[i] = ival;
            if (ival > max_sqr) {
                max_sqr = ival;
            }
        }

        for (int i = 0; i < 204 * 16; i++) {
            value = 163.67 / (24329.0 / ((double) i / 16.0) + 100.0);
            value *= 0.98411;
            value *= 50000.0;
            ival = (int) value;

            tnd_table[i] = ival;
            if (ival > max_tnd) {
                max_tnd = ival;
            }
        }

        this.dacRange = max_sqr + max_tnd;
        this.dcValue = dacRange / 2;
    }

    public void destroy() {
        nes = null;
        cpuMem = null;

        if (square1 != null) square1.destroy();
        if (square2 != null) square2.destroy();
        if (triangle != null) triangle.destroy();
        if (noise != null) noise.destroy();
        if (dmc != null) dmc.destroy();

        square1 = null;
        square2 = null;
        triangle = null;
        noise = null;
        dmc = null;

        mixer = null;
        line = null;
        
        if (modernAudio != null) {
            modernAudio.close();;
            modernAudio = null;
        }
    }

    public void testAudioSystem() {
    System.out.println("=== TESTE DO SISTEMA DE √ÅUDIO ===");
            if (modernAudio == null) {
                System.err.println("ModernAudioSystem √© null");
                return;
            }
                    System.out.println("ModernAudioSystem inicializado: " + modernAudio.isInitialized());
                    // Teste: gerar um beep de 1 segundo
                    try {
                        System.out.println("Gerando beep de teste...");
                        // Gerar beep de 440Hz por 1 segundo
                        byte[] testBuffer = generateTestBeep(440, 1000);
                        System.out.println("Buffer de teste gerado: " + testBuffer.length + " bytes");
                        // Enviar o beep usando o m√©todo correto
                        modernAudio.write(testBuffer); // Usar o m√©todo sem par√¢metros
                        System.out.println("Beep enviado: SUCESSO"); 
                        // Dar tempo para reproduzir - AGORA O M√âTODO drain() EXISTE
                        modernAudio.drain();
                        Thread.sleep(300);
                            
                    } catch (Exception e) {
                        System.err.println("Erro no teste de √°udio: " + e.getMessage());
                        e.printStackTrace();
                    }
                    System.out.println("=== FIM DO TESTE ===");
        }

            

    private byte[] generateTestBeep(double frequency, int durationMs) {
            int sampleRate = 44100;
            int samples = (int) (sampleRate * durationMs / 1000.0);
            byte[] data = new byte[samples * 4]; // stereo 16-bit
            
            double volume = 0.5;
            
            for (int i = 0; i < samples; i++) {
                double time = i / (double) sampleRate;
                double value = Math.sin(2 * Math.PI * frequency * time) * volume;
                short sample = (short) (value * Short.MAX_VALUE);
                
                int index = i * 4;
                data[index] = (byte) (sample & 0xFF);
                data[index + 1] = (byte) ((sample >> 8) & 0xFF);
                data[index + 2] = data[index];     // Left channel
                data[index + 3] = data[index + 1]; // Right channel (same as left)
            }
            
            return data;
        }
}

    

